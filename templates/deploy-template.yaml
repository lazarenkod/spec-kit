# Deployment Specification Template
# Generated by /speckit.plan from Technical Context section
# Used by /speckit.ship for application deployment

apiVersion: speckit.dev/v1
kind: DeploymentSpec

metadata:
  # Feature identification
  feature: "{{FEATURE_ID}}"           # e.g., "001-user-auth"
  version: "1.0.0"
  created: "{{TIMESTAMP}}"
  updated: "{{TIMESTAMP}}"

  # Traceability to plan.md
  plan_ref: "plan.md#technical-context"

# =============================================================================
# BUILD CONFIGURATION
# =============================================================================
build:
  # Container image settings
  image:
    registry: "registry.vk.cloud/{{PROJECT}}"
    # Yandex: registry: "cr.yandex/{{PROJECT}}"
    # GCP: registry: "gcr.io/{{PROJECT}}"
    name: app
    # Tag is set dynamically: ${GIT_SHA} or ${RELEASE_TAG}

  # Dockerfile location
  dockerfile: ./Dockerfile
  context: .

  # Build arguments
  args:
    NODE_ENV: production
    # Add build-time variables here

  # Multi-stage build targets (optional)
  # target: production

# =============================================================================
# LOCAL ENVIRONMENT (docker-compose)
# =============================================================================
environments:
  local:
    method: docker-compose
    description: "Local development with hot reload"

    # Services to deploy
    services:
      # Main application
      - name: app
        build:
          context: .
          dockerfile: Dockerfile.dev    # Development Dockerfile with hot reload
        ports:
          - "8080:8080"
        volumes:
          - ./src:/app/src              # Hot reload
          - /app/node_modules           # Preserve node_modules
        environment:
          NODE_ENV: development
          # Database connection (from infra.yaml local)
          DATABASE_URL: "postgres://postgres:localdev@postgres:5432/{{PROJECT}}_dev"
          REDIS_URL: "redis://redis:6379"
          # Feature flags
          DEBUG: "true"
          LOG_LEVEL: debug
        depends_on:
          postgres:
            condition: service_healthy
          redis:
            condition: service_healthy
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
          interval: 10s
          timeout: 5s
          retries: 3

      # Background worker (optional)
      # - name: worker
      #   build:
      #     context: .
      #     target: worker
      #   environment:
      #     DATABASE_URL: "postgres://postgres:localdev@postgres:5432/{{PROJECT}}_dev"
      #     REDIS_URL: "redis://redis:6379"
      #   depends_on:
      #     - postgres
      #     - redis

    # Compose file generation options
    compose:
      version: "3.8"
      output_path: .speckit/local/docker-compose.yml
      # Include infra services from infra.yaml
      include_infra: true

# =============================================================================
# STAGING ENVIRONMENT (Helm + kubectl)
# =============================================================================
  staging:
    method: helm
    description: "Shared staging cluster with feature namespaces"

    # Namespace strategy: each feature gets its own namespace
    namespace:
      pattern: "staging-{{FEATURE_SLUG}}"
      # Example: staging-001-user-auth
      labels:
        environment: staging
        feature: "{{FEATURE_ID}}"
        managed-by: speckit
      annotations:
        speckit.dev/feature-id: "{{FEATURE_ID}}"
        speckit.dev/git-branch: "{{GIT_BRANCH}}"

    # Helm chart configuration
    chart:
      path: ./helm/app                  # Local chart path
      # Or use remote chart:
      # repository: https://charts.example.com
      # name: app
      # version: "1.0.0"

    # Values files (applied in order)
    values:
      - helm/values/base.yaml           # Base configuration
      - helm/values/staging.yaml        # Staging overrides

    # Dynamic values (set via --set)
    set:
      # Image configuration
      image.repository: "{{build.image.registry}}/{{build.image.name}}"
      image.tag: "{{GIT_SHA}}"
      image.pullPolicy: Always

      # Replicas
      replicaCount: 2

      # Resource limits
      resources.requests.cpu: 100m
      resources.requests.memory: 256Mi
      resources.limits.cpu: 500m
      resources.limits.memory: 512Mi

      # Ingress
      ingress.enabled: true
      ingress.host: "{{FEATURE_SLUG}}.staging.{{DOMAIN}}"
      ingress.tls.enabled: true
      ingress.annotations.kubernetes\\.io/ingress\\.class: nginx

      # Environment variables from infra outputs
      env.DATABASE_HOST: "{{INFRA_OUTPUTS.DATABASE_HOST}}"
      env.DATABASE_PORT: "{{INFRA_OUTPUTS.DATABASE_PORT}}"
      env.DATABASE_NAME: "{{INFRA_OUTPUTS.DATABASE_NAME}}"
      env.REDIS_HOST: "{{INFRA_OUTPUTS.REDIS_HOST}}"
      env.REDIS_PORT: "{{INFRA_OUTPUTS.REDIS_PORT}}"
      env.S3_BUCKET: "{{INFRA_OUTPUTS.S3_BUCKET}}"
      env.S3_ENDPOINT: "{{INFRA_OUTPUTS.S3_ENDPOINT}}"

    # Secrets (from Kubernetes secrets or external secret manager)
    secrets:
      # Database credentials
      - name: database-credentials
        type: kubernetes                # kubernetes | vault | aws-secrets-manager
        secret_name: "{{PROJECT}}-db-credentials"
        keys:
          - DATABASE_USER
          - DATABASE_PASSWORD

    # Deployment options
    deploy:
      timeout: 5m
      wait: true                        # Wait for rollout to complete
      atomic: true                      # Rollback on failure
      cleanup_on_fail: true

    # Health checks (for rollout verification)
    health:
      initial_delay: 10s
      period: 5s
      timeout: 3s
      success_threshold: 1
      failure_threshold: 3

# =============================================================================
# PRODUCTION ENVIRONMENT
# =============================================================================
  production:
    method: helm
    description: "Production environment with high availability"

    # Fixed namespace for production
    namespace:
      name: production
      labels:
        environment: production
        managed-by: speckit

    # Inherit chart from staging
    chart:
      path: ./helm/app

    # Production values
    values:
      - helm/values/base.yaml
      - helm/values/production.yaml

    # Production overrides
    set:
      image.repository: "{{build.image.registry}}/{{build.image.name}}"
      image.tag: "{{RELEASE_TAG}}"      # Use release tag, not git SHA
      image.pullPolicy: IfNotPresent

      # Higher replicas
      replicaCount: 3

      # More resources
      resources.requests.cpu: 500m
      resources.requests.memory: 512Mi
      resources.limits.cpu: 2000m
      resources.limits.memory: 2Gi

      # Production ingress
      ingress.host: "app.{{DOMAIN}}"

      # HPA (Horizontal Pod Autoscaler)
      autoscaling.enabled: true
      autoscaling.minReplicas: 3
      autoscaling.maxReplicas: 10
      autoscaling.targetCPUUtilization: 70

      # PDB (Pod Disruption Budget)
      podDisruptionBudget.enabled: true
      podDisruptionBudget.minAvailable: 2

    # Production secrets
    secrets:
      - name: database-credentials
        type: vault                     # Use Vault in production
        path: "secret/data/{{PROJECT}}/production/db"
        keys:
          - DATABASE_USER
          - DATABASE_PASSWORD

    # Stricter deployment
    deploy:
      timeout: 10m
      wait: true
      atomic: true
      # Require manual approval for production
      # approval_required: true

# =============================================================================
# ROLLBACK CONFIGURATION
# =============================================================================
rollback:
  # Number of revisions to keep
  history_limit: 10

  # Automatic rollback on failed health checks
  auto_rollback: true

  # Rollback command template
  command: |
    helm rollback {{RELEASE_NAME}} {{REVISION}} \
      --namespace {{NAMESPACE}} \
      --wait --timeout=5m

# =============================================================================
# POST-DEPLOY HOOKS
# =============================================================================
hooks:
  # Run after successful deployment
  post_deploy:
    # Database migrations
    - name: run-migrations
      type: job
      image: "{{build.image.registry}}/{{build.image.name}}:{{GIT_SHA}}"
      command: ["npm", "run", "migrate"]
      # Or for Python: ["python", "manage.py", "migrate"]
      timeout: 5m
      # Only run if migrations exist
      condition: "migrations_pending"

    # Cache warmup
    # - name: warmup-cache
    #   type: job
    #   command: ["npm", "run", "warmup"]
    #   timeout: 2m

  # Run before deployment
  pre_deploy:
    # Backup database (production only)
    - name: backup-database
      type: script
      script: scripts/backup-db.sh
      environments: [production]
      timeout: 10m
