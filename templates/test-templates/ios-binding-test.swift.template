// iOS Binding Test Template for KMP ViewModels
// Generated by spec-kit binding-test-generator
//
// Variables:
//   - viewmodel_name: Name of the ViewModel (e.g., "AuthViewModel")
//   - wrapper_name: Name of the wrapper class (e.g., "AuthViewModelWrapper")
//   - methods: List of methods to test
//
// Usage:
//   This template generates XCTest binding tests for iOS wrappers
//   that call KMP shared ViewModels.

import XCTest
@testable import SharedKMP

// @speckit:BINDING-TEST-FILE:{{ viewmodel_name }}
class {{ viewmodel_name }}BindingTests: XCTestCase {
    var sut: {{ wrapper_name }}!
    var mockViewModel: Mock{{ viewmodel_name }}!

    override func setUp() {
        super.setUp()
        mockViewModel = Mock{{ viewmodel_name }}()
        sut = {{ wrapper_name }}(viewModel: mockViewModel)
    }

    override func tearDown() {
        sut = nil
        mockViewModel = nil
        super.tearDown()
    }

    {% for method in methods %}
    {% if method.return_type == "Unit" %}
    // @speckit:BINDING-TEST:{{ viewmodel_name }}:{{ method.name }}
    func test_{{ method.name }}_callsViewModel() {
        // When
        sut.{{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.test_value }}{% if not loop.last %}, {% endif %}{% endfor %})

        // Then
        XCTAssertTrue(mockViewModel.{{ method.name }}Called, "{{ method.name }}() should call viewModel.{{ method.name }}()")
        {% for param in method.parameters %}
        XCTAssertEqual(mockViewModel.{{ method.name }}{{ param.name|capitalize }}, {{ param.test_value }})
        {% endfor %}
    }

    {% elif method.return_type == "Flow" %}
    // @speckit:BINDING-TEST:{{ viewmodel_name }}:{{ method.name }}
    func test_{{ method.name }}_publishesViewModelFlow() {
        // Given
        let expected{{ method.flow_type }} = {{ method.test_value }}
        mockViewModel.{{ method.name }}Flow = Just(expected{{ method.flow_type }}).eraseToAnyPublisher()
        var received{{ method.flow_type }}: {{ method.flow_type }}?
        let expectation = expectation(description: "{{ method.flow_type }} received")

        // When
        let cancellable = sut.{{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.test_value }}{% if not loop.last %}, {% endif %}{% endfor %})
            .sink(receiveCompletion: { _ in },
                  receiveValue: { value in
                      received{{ method.flow_type }} = value
                      expectation.fulfill()
                  })

        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertEqual(received{{ method.flow_type }}?.id, expected{{ method.flow_type }}.id, "{{ method.name }}() should publish viewModel flow values")
        cancellable.cancel()
    }

    {% elif method.is_suspend %}
    // @speckit:BINDING-TEST:{{ viewmodel_name }}:{{ method.name }}
    func test_{{ method.name }}_callsViewModelSuspendFunction() async throws {
        // Given
        let expectedResult = {{ method.test_value }}
        mockViewModel.{{ method.name }}Result = .success(expectedResult)

        // When
        let result = try await sut.{{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.test_value }}{% if not loop.last %}, {% endif %}{% endfor %})

        // Then
        XCTAssertTrue(mockViewModel.{{ method.name }}Called, "{{ method.name }}() should call viewModel.{{ method.name }}()")
        {% for param in method.parameters %}
        XCTAssertEqual(mockViewModel.{{ method.name }}{{ param.name|capitalize }}, {{ param.test_value }})
        {% endfor %}

        switch result {
        case .success(let value):
            XCTAssertEqual(value.id, expectedResult.id)
        case .failure:
            XCTFail("Expected success, got failure")
        }
    }

    {% else %}
    // @speckit:BINDING-TEST:{{ viewmodel_name }}:{{ method.name }}
    func test_{{ method.name }}_returnsViewModelValue() {
        // Given
        mockViewModel.{{ method.name }}ReturnValue = {{ method.test_value }}

        // When
        let result = sut.{{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.test_value }}{% if not loop.last %}, {% endif %}{% endfor %})

        // Then
        XCTAssertEqual(result, {{ method.test_value }}, "{{ method.name }}() should return viewModel.{{ method.name }}() value")
        XCTAssertTrue(mockViewModel.{{ method.name }}Called, "{{ method.name }}() should call viewModel.{{ method.name }}()")
        {% for param in method.parameters %}
        XCTAssertEqual(mockViewModel.{{ method.name }}{{ param.name|capitalize }}, {{ param.test_value }})
        {% endfor %}
    }

    {% endif %}
    {% endfor %}
}

// MARK: - Mock{{ viewmodel_name }}

class Mock{{ viewmodel_name }}: {{ viewmodel_name }} {
    {% for method in methods %}
    // {{ method.name }} mock
    var {{ method.name }}Called = false
    {% for param in method.parameters %}
    var {{ method.name }}{{ param.name|capitalize }}: {{ param.type }}?
    {% endfor %}
    {% if method.return_type == "Flow" %}
    var {{ method.name }}Flow: AnyPublisher<{{ method.flow_type }}, Never>!
    {% elif method.is_suspend %}
    var {{ method.name }}Result: Result<{{ method.return_type }}, Error>!
    {% elif method.return_type != "Unit" %}
    var {{ method.name }}ReturnValue: {{ method.return_type }}!
    {% endif %}

    {% if method.return_type == "Unit" %}
    override func {{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) {
        {{ method.name }}Called = true
        {% for param in method.parameters %}
        self.{{ method.name }}{{ param.name|capitalize }} = {{ param.name }}
        {% endfor %}
    }
    {% elif method.return_type == "Flow" %}
    override func {{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> AnyPublisher<{{ method.flow_type }}, Never> {
        {{ method.name }}Called = true
        {% for param in method.parameters %}
        self.{{ method.name }}{{ param.name|capitalize }} = {{ param.name }}
        {% endfor %}
        return {{ method.name }}Flow
    }
    {% elif method.is_suspend %}
    override func {{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) async throws -> {{ method.return_type }} {
        {{ method.name }}Called = true
        {% for param in method.parameters %}
        self.{{ method.name }}{{ param.name|capitalize }} = {{ param.name }}
        {% endfor %}
        return try {{ method.name }}Result.get()
    }
    {% else %}
    override func {{ method.name }}({% for param in method.parameters %}{{ param.name }}: {{ param.type }}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ method.return_type }} {
        {{ method.name }}Called = true
        {% for param in method.parameters %}
        self.{{ method.name }}{{ param.name|capitalize }} = {{ param.name }}
        {% endfor %}
        return {{ method.name }}ReturnValue
    }
    {% endif %}

    {% endfor %}
}
