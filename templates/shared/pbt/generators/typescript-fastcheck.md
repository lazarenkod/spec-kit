# TypeScript fast-check Generator Template

This document defines the code generation templates for TypeScript property-based tests using [fast-check](https://fast-check.dev/).

## File Structure

```
tests/
‚îî‚îÄ‚îÄ properties/
    ‚îú‚îÄ‚îÄ arbitraries.ts            # Custom arbitraries (generators)
    ‚îî‚îÄ‚îÄ [feature].property.test.ts  # Property tests
```

---

## Template: arbitraries.ts

```typescript
// tests/properties/arbitraries.ts
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Custom arbitraries for property-based tests

import fc from 'fast-check';

// =============================================================================
// PRIMITIVE ARBITRARIES
// =============================================================================

// String arbitraries
export const validEmail = fc.emailAddress();
export const validUuid = fc.uuid();
export const validUrl = fc.webUrl();
export const validPhone = fc.stringMatching(/^\+1[0-9]{10}$/);

// Numeric arbitraries
export const positiveInt = fc.integer({ min: 1 });
export const nonNegativeInt = fc.nat();
export const percentage = fc.float({ min: 0, max: 100 });
export const moneyAmount = fc.float({ min: 0, max: 999999.99, noNaN: true })
  .map(n => Math.round(n * 100) / 100);

// Date arbitraries
export const futureDate = fc.date({ min: new Date() });
export const pastDate = fc.date({ max: new Date() });

// =============================================================================
// BOUNDARY ARBITRARIES
// =============================================================================

export const invalidEmail = fc.oneof(
  fc.constant(''),                              // Empty
  fc.constant('@'),                             // No local part
  fc.constant('a@'),                            // No domain
  fc.constant('@b.com'),                        // No local part
  fc.constant('a@b'),                           // No TLD
  fc.constant('a@@b.com'),                      // Double @
  fc.string().filter(s => !s.includes('@')),    // Missing @
  fc.string().filter(s => (s.match(/@/g) || []).length > 1), // Multiple @
);

export const boundaryString = fc.oneof(
  fc.constant(''),                              // Empty
  fc.constant(' '),                             // Whitespace only
  fc.constant('\n'),                            // Newline only
  fc.constant('\t'),                            // Tab only
  fc.constant('a'.repeat(1000)),                // Very long
  fc.stringOf(fc.constantFrom('üéâ', 'üéä', 'üéÅ')), // Emoji only
);

export const boundaryInt = fc.oneof(
  fc.constant(0),
  fc.constant(-1),
  fc.constant(1),
  fc.constant(Number.MAX_SAFE_INTEGER),
  fc.constant(Number.MIN_SAFE_INTEGER),
);

// =============================================================================
// SECURITY ARBITRARIES
// =============================================================================

export const sqlInjectionPayloads = fc.oneof(
  fc.constant("'; DROP TABLE users; --"),
  fc.constant("' OR '1'='1"),
  fc.constant("admin'--"),
  fc.constant("1; SELECT * FROM users"),
  fc.constant("' UNION SELECT * FROM users--"),
  fc.constant("1' AND '1'='1"),
  fc.stringMatching(/.*[';].*/),
);

export const xssPayloads = fc.oneof(
  fc.constant("<script>alert('xss')</script>"),
  fc.constant("<img src=x onerror=alert('xss')>"),
  fc.constant("javascript:alert('xss')"),
  fc.constant("<svg onload=alert('xss')>"),
  fc.constant("'><script>alert('xss')</script>"),
);

export const pathTraversalPayloads = fc.oneof(
  fc.constant('../../../etc/passwd'),
  fc.constant('..\\..\\..\\windows\\system32'),
  fc.constant('%2e%2e%2f%2e%2e%2f'),
  fc.constant('....//....//'),
);

export const commandInjectionPayloads = fc.oneof(
  fc.constant('; rm -rf /'),
  fc.constant('| cat /etc/passwd'),
  fc.constant('$(whoami)'),
  fc.constant('`id`'),
  fc.constant('& ping -c 10 localhost &'),
);

// =============================================================================
// ENTITY ARBITRARIES
// =============================================================================

{% for entity in entities %}
// {{entity.name}} arbitraries
export const valid{{entity.name}} = fc.record({
  {% for field in entity.fields %}
  {{field.name}}: {{field.valid_arbitrary}},
  {% endfor %}
});

export const boundary{{entity.name}} = fc.record({
  {% for field in entity.fields %}
  {{field.name}}: {{field.boundary_arbitrary}},
  {% endfor %}
});

{% if entity.has_security_fields %}
export const security{{entity.name}} = fc.record({
  {% for field in entity.security_fields %}
  {{field.name}}: {{field.security_arbitrary}},
  {% endfor %}
});
{% endif %}

export type {{entity.name}} = {
  {% for field in entity.fields %}
  {{field.name}}: {{field.typescript_type}};
  {% endfor %}
};
{% endfor %}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Deep equality check for arbitrary values
 */
export function deepEqual<T>(a: T, b: T): boolean {
  return JSON.stringify(a) === JSON.stringify(b);
}

/**
 * Create a shrunk example arbitrary from a list of known examples
 */
export function withShrunkExamples<T>(
  arbitrary: fc.Arbitrary<T>,
  examples: T[]
): fc.Arbitrary<T> {
  if (examples.length === 0) return arbitrary;
  return fc.oneof(
    { arbitrary, weight: 10 },
    ...examples.map(ex => ({ arbitrary: fc.constant(ex), weight: 1 }))
  );
}
```

---

## Template: Property Test File

```typescript
// tests/properties/{{feature_name}}.property.test.ts
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Generated: {{TIMESTAMP}}
//
// Property-Based Tests for {{FEATURE_NAME}}
// Based on: spec.md, properties.md
//
// Run: npm run test:properties

import fc from 'fast-check';
import { describe, it, expect, beforeEach, afterEach } from 'vitest'; // or jest

// Import arbitraries
import {
  validEmail, invalidEmail,
  validUser, boundaryUser, securityUser,
  sqlInjectionPayloads, xssPayloads,
  deepEqual, withShrunkExamples,
  // ... other arbitraries
} from './arbitraries';

// Import system under test
import {
  createUser, deleteUser, userExists,
  loginUser, verifyToken,
  // ... other functions
} from '{{module}}';
import { ValidationError, DuplicateError } from '{{module}}/errors';

// =============================================================================
// TEST CONFIGURATION
// =============================================================================

const fcConfig = {
  numRuns: 100,
  verbose: true,
  endOnFailure: true,
};

// Shrunk examples from previous runs
const shrunkExamples = {
  {% for prop in properties if prop.shrunk_examples %}
  '{{prop.id}}': {{prop.shrunk_examples | json}},
  {% endfor %}
};

// =============================================================================
// INVERSE PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "inverse" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Inverse)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * Formula: {{prop.formula}}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  it('should satisfy: {{prop.formula}}', () => {
    fc.assert(
      fc.property(
        withShrunkExamples({{prop.generator}}, shrunkExamples['{{prop.id}}'] || []),
        (value) => {
          // Forward operation
          const result = {{prop.forward_function}}(value);
          expect({{prop.forward_assertion}}).toBe(true);

          // Inverse operation
          const recovered = {{prop.inverse_function}}(result);

          // Round-trip assertion
          return deepEqual(recovered, value) || {{prop.custom_equality}};
        }
      ),
      { ...fcConfig, examples: shrunkExamples['{{prop.id}}']?.map(e => [e]) || [] }
    );
  });
});

{% endfor %}

// =============================================================================
// IDEMPOTENT PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "idempotent" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Idempotent)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * Formula: {{prop.formula}}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  it('should satisfy: {{prop.formula}}', () => {
    fc.assert(
      fc.property({{prop.generator}}, (value) => {
        // Apply once
        const once = {{prop.function}}(value);

        // Apply twice
        const twice = {{prop.function}}(once);

        // Idempotent assertion
        return deepEqual(once, twice);
      }),
      fcConfig
    );
  });
});

{% endfor %}

// =============================================================================
// INVARIANT PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "invariant" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Invariant)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * Formula: {{prop.formula}}
   * {% if prop.statistical %}Statistical: Yes (samples={{prop.sample_size}}){% endif %}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  it('should maintain: {{prop.formula}}', () => {
    fc.assert(
      fc.property({{prop.generator}}, (state) => {
        {% if prop.conditional %}
        // Precondition check
        fc.pre({{prop.condition}});
        {% endif %}

        // Operation
        const result = {{prop.operation}}(state);

        // Invariant check
        return {{prop.invariant_check}};
      }),
      { ...fcConfig, numRuns: {{prop.sample_size if prop.statistical else 100}} }
    );
  });
});

{% endfor %}

// =============================================================================
// BOUNDARY PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "boundary" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Boundary)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * Severity: {{prop.severity}}
   * {% if prop.security_category %}Security: {{prop.security_category}}{% endif %}
   * EARS: {{prop.ears_form}}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  it('should reject boundary values with: {{prop.expected_exception}}', () => {
    fc.assert(
      fc.property(
        withShrunkExamples({{prop.boundary_generator}}, shrunkExamples['{{prop.id}}'] || []),
        (boundaryValue) => {
          expect(() => {{prop.operation}}(boundaryValue)).toThrow({{prop.expected_exception}});
          return true;
        }
      ),
      { ...fcConfig, examples: shrunkExamples['{{prop.id}}']?.map(e => [e]) || [] }
    );
  });

  {% if prop.security_category %}
  it('should prevent security attacks: {{prop.security_category}}', () => {
    fc.assert(
      fc.property({{prop.security_generator}}, (attackPayload) => {
        try {
          const result = {{prop.operation}}(attackPayload);
          // If didn't throw, verify sanitization
          expect({{prop.sanitization_check}}).toBe(true);
          return true;
        } catch (error) {
          // Expected - attack was rejected
          expect(error).toBeInstanceOf({{prop.expected_exception}});
          return true;
        }
      }),
      fcConfig
    );
  });
  {% endif %}
});

{% endfor %}

// =============================================================================
// COMMUTATIVE PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "commutative" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Commutative)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * Formula: {{prop.formula}}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  it('should satisfy: {{prop.formula}}', () => {
    fc.assert(
      fc.property({{prop.generator_a}}, {{prop.generator_b}}, (a, b) => {
        // Both orders
        const resultAB = {{prop.function}}(a, b);
        const resultBA = {{prop.function}}(b, a);

        // Commutative assertion
        return deepEqual(resultAB, resultBA);
      }),
      fcConfig
    );
  });
});

{% endfor %}

// =============================================================================
// MODEL-BASED PROPERTIES (Command-Based Testing)
// =============================================================================

{% for prop in properties if prop.type == "model_based" %}
describe('PROP-{{prop.id}}: {{prop.name}} (Model-Based)', () => {
  /**
   * {{prop.description}}
   * Trace: {{prop.trace}}
   * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
   */

  // Define model type
  type Model = {{prop.model_type}};
  type Real = {{prop.real_type}};

  // Define commands
  {% for cmd in prop.commands %}
  const {{cmd.name}}Command = fc.record({
    {% for field in cmd.fields %}
    {{field.name}}: {{field.arbitrary}},
    {% endfor %}
  }).map((params): fc.Command<Model, Real> => ({
    check: (m: Model) => {{cmd.guard}},
    run: (m: Model, r: Real) => {
      // Update model
      {{cmd.model_update}};
      // Update real system
      {{cmd.real_update}};
      // Assert consistency
      expect(r.getState()).toEqual(m.state);
    },
    toString: () => `{{cmd.name}}(${JSON.stringify(params)})`,
  }));
  {% endfor %}

  // Run model-based test
  it('should maintain model consistency across all transitions', () => {
    fc.assert(
      fc.property(
        fc.commands([
          {% for cmd in prop.commands %}
          {{cmd.name}}Command,
          {% endfor %}
        ], { maxCommands: 50 }),
        (commands) => {
          const setup = () => ({
            model: new {{prop.model_class}}(),
            real: new {{prop.real_class}}(),
          });
          fc.modelRun(setup, commands);
          return true;
        }
      ),
      { ...fcConfig, numRuns: 100 }
    );
  });
});

{% endfor %}
```

---

## Running Tests

```bash
# Run all property tests
npm run test:properties

# Run with vitest
npx vitest tests/properties/ --run

# Run with jest
npx jest tests/properties/ --verbose

# Run specific test file
npx vitest tests/properties/user.property.test.ts

# Run with coverage
npx vitest tests/properties/ --coverage

# Run with seed for reproducibility
npx vitest tests/properties/ --seed 12345
```

---

## Package.json Scripts

```json
{
  "scripts": {
    "test:properties": "vitest run tests/properties/",
    "test:properties:watch": "vitest tests/properties/",
    "test:properties:coverage": "vitest run tests/properties/ --coverage"
  },
  "devDependencies": {
    "fast-check": "^3.15.0",
    "vitest": "^1.0.0"
  }
}
```

---

## Best Practices

### 1. Use fc.pre() for Preconditions

```typescript
fc.assert(
  fc.property(fc.integer(), (n) => {
    fc.pre(n > 0); // Skip non-positive
    return Math.sqrt(n) ** 2 === n;
  })
);
```

### 2. Custom Arbitraries with Constraints

```typescript
const validPassword = fc.string({ minLength: 8, maxLength: 128 })
  .filter(p => /[A-Z]/.test(p) && /[a-z]/.test(p) && /[0-9]/.test(p));
```

### 3. Record-Based Entity Arbitraries

```typescript
const validUser = fc.record({
  email: fc.emailAddress(),
  password: validPassword,
  name: fc.string({ minLength: 1, maxLength: 100 }),
});
```

### 4. Weighted Oneofs for Edge Cases

```typescript
const emailArbitrary = fc.oneof(
  { arbitrary: fc.emailAddress(), weight: 10 },  // Most common
  { arbitrary: fc.constant(''), weight: 1 },     // Edge case
  { arbitrary: invalidEmail, weight: 1 },        // Invalid
);
```

### 5. Model-Based Testing with Commands

```typescript
const addItemCommand = fc.record({
  item: validItem,
}).map((params): fc.Command<CartModel, Cart> => ({
  check: (m) => m.items.length < 100,
  run: (m, r) => {
    m.add(params.item);
    r.add(params.item);
    expect(r.total).toBe(m.total);
  },
  toString: () => `addItem(${params.item.name})`,
}));
```
