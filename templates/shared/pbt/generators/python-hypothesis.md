# Python Hypothesis Generator Template

This document defines the code generation templates for Python property-based tests using [Hypothesis](https://hypothesis.readthedocs.io/).

## File Structure

```
tests/
â””â”€â”€ properties/
    â”œâ”€â”€ conftest.py           # Shared generators and fixtures
    â”œâ”€â”€ generators.py         # Custom domain generators
    â””â”€â”€ test_[feature]_properties.py  # Property tests
```

---

## Template: conftest.py

```python
# tests/properties/conftest.py
# Generated by /speckit.properties
# Shared configuration for property-based tests

import pytest
from hypothesis import settings, Phase, Verbosity

# =============================================================================
# HYPOTHESIS CONFIGURATION
# =============================================================================

# Default settings for property tests
settings.register_profile(
    "default",
    max_examples=100,
    deadline=None,
    suppress_health_check=[],
    phases=[Phase.generate, Phase.shrink],
    verbosity=Verbosity.normal
)

settings.register_profile(
    "ci",
    max_examples=200,
    deadline=None,
    phases=[Phase.generate, Phase.shrink],
    verbosity=Verbosity.quiet
)

settings.register_profile(
    "debug",
    max_examples=10,
    deadline=None,
    verbosity=Verbosity.verbose
)

settings.load_profile("default")

# =============================================================================
# SHARED FIXTURES
# =============================================================================

@pytest.fixture
def clean_state():
    """Reset state before each property test."""
    # Setup
    yield
    # Teardown
    pass
```

---

## Template: generators.py

```python
# tests/properties/generators.py
# Generated by /speckit.properties
# Feature: {{FEATURE_ID}}
# Custom domain generators for property-based tests

from hypothesis import strategies as st
from hypothesis.strategies import (
    builds, composite, just, one_of, none,
    text, emails, integers, floats, decimals,
    booleans, dates, datetimes, uuids,
    lists, dictionaries, sampled_from, from_regex
)
from datetime import date, datetime, timedelta
from decimal import Decimal

# =============================================================================
# PRIMITIVE GENERATORS
# =============================================================================

# String generators
valid_email = emails()
valid_uuid = uuids().map(str)
valid_url = from_regex(r'https?://[a-z]+\.[a-z]{2,4}(/[a-z]+)*', fullmatch=True)
valid_phone = from_regex(r'\+1[0-9]{10}', fullmatch=True)

# Numeric generators
positive_int = integers(min_value=1)
non_negative_int = integers(min_value=0)
percentage = floats(min_value=0.0, max_value=100.0)
money_amount = decimals(min_value=Decimal('0.00'), max_value=Decimal('999999.99'), places=2)

# Date generators
future_date = dates(min_value=date.today() + timedelta(days=1))
past_date = dates(max_value=date.today() - timedelta(days=1))

# =============================================================================
# BOUNDARY GENERATORS
# =============================================================================

invalid_email = one_of(
    just(""),                                    # Empty
    just("@"),                                   # No local part
    just("a@"),                                  # No domain
    just("@b.com"),                              # No local part
    just("a@b"),                                 # No TLD
    just("a@@b.com"),                            # Double @
    text().filter(lambda x: "@" not in x),       # Missing @
    text().filter(lambda x: x.count("@") > 1),   # Multiple @
)

boundary_string = one_of(
    just(""),                                    # Empty
    just(" "),                                   # Whitespace only
    just("\n"),                                  # Newline only
    just("\t"),                                  # Tab only
    just("a" * 1000),                            # Very long
    text(alphabet="ğŸ‰ğŸŠğŸ", min_size=1),          # Emoji only
)

boundary_int = one_of(
    just(0),
    just(-1),
    just(1),
    just(2**31 - 1),    # Max 32-bit signed
    just(-2**31),       # Min 32-bit signed
    just(2**63 - 1),    # Max 64-bit signed
)

# =============================================================================
# SECURITY GENERATORS
# =============================================================================

sql_injection_payloads = one_of(
    just("'; DROP TABLE users; --"),
    just("' OR '1'='1"),
    just("admin'--"),
    just("1; SELECT * FROM users"),
    just("' UNION SELECT * FROM users--"),
    just("1' AND '1'='1"),
    from_regex(r".*[';].*", fullmatch=True),
)

xss_payloads = one_of(
    just("<script>alert('xss')</script>"),
    just("<img src=x onerror=alert('xss')>"),
    just("javascript:alert('xss')"),
    just("<svg onload=alert('xss')>"),
    just("'><script>alert('xss')</script>"),
)

path_traversal_payloads = one_of(
    just("../../../etc/passwd"),
    just("..\\..\\..\\windows\\system32"),
    just("%2e%2e%2f%2e%2e%2f"),
    just("....//....//"),
)

command_injection_payloads = one_of(
    just("; rm -rf /"),
    just("| cat /etc/passwd"),
    just("$(whoami)"),
    just("`id`"),
    just("& ping -c 10 localhost &"),
)

# =============================================================================
# ENTITY GENERATORS
# =============================================================================

{% for entity in entities %}
# {{entity.name}} generators
valid_{{entity.name|lower}} = builds(
    dict,
    {% for field in entity.fields %}
    {{field.name}}={{field.valid_generator}},
    {% endfor %}
)

boundary_{{entity.name|lower}} = builds(
    dict,
    {% for field in entity.fields %}
    {{field.name}}={{field.boundary_generator}},
    {% endfor %}
)

{% if entity.has_security_fields %}
security_{{entity.name|lower}} = builds(
    dict,
    {% for field in entity.security_fields %}
    {{field.name}}={{field.security_generator}},
    {% endfor %}
)
{% endif %}
{% endfor %}

# =============================================================================
# COMPOSITE GENERATORS
# =============================================================================

@composite
def valid_{{entity.name|lower}}_with_relations(draw):
    """Generate {{entity.name}} with valid related entities."""
    base = draw(valid_{{entity.name|lower}})
    {% for rel in entity.relationships %}
    base["{{rel.field}}"] = draw(valid_{{rel.to|lower}}())
    {% endfor %}
    return base
```

---

## Template: Property Test File

```python
# tests/properties/test_{{feature_name}}_properties.py
# Generated by /speckit.properties
# Feature: {{FEATURE_ID}}
# Generated: {{TIMESTAMP}}
#
# Property-Based Tests for {{FEATURE_NAME}}
# Based on: spec.md, properties.md
#
# Run: pytest tests/properties/ -v --hypothesis-show-statistics

import pytest
from hypothesis import given, settings, assume, example, note
from hypothesis import strategies as st
from hypothesis.stateful import RuleBasedStateMachine, rule, invariant, precondition

# Import generators
from .generators import (
    valid_email, invalid_email,
    valid_user, boundary_user, security_user,
    sql_injection_payloads, xss_payloads,
    # ... other generators
)

# Import system under test
from {{module}} import (
    create_user, delete_user, user_exists,
    login_user, verify_token,
    # ... other functions
)
from {{module}}.exceptions import ValidationError, DuplicateError

# =============================================================================
# INVERSE PROPERTIES
# =============================================================================

{% for prop in properties if prop.type == "inverse" %}
class Test{{prop.name}}Inverse:
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}
    Formula: {{prop.formula}}
    """

    @given({{prop.generator}})
    @settings(max_examples=100, deadline=None)
    {% for ex in prop.shrunk_examples %}
    @example({{ex}})
    {% endfor %}
    def test_{{prop.name|lower}}_inverse(self, value):
        """
        Property: {{prop.formula}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
        """
        # Arrange
        original = value

        # Act - forward operation
        result = {{prop.forward_function}}(original)
        assert {{prop.forward_assertion}}, "Forward operation failed"

        # Act - inverse operation
        recovered = {{prop.inverse_function}}(result)

        # Assert - round-trip
        assert {{prop.inverse_assertion}}, \
            f"Inverse property violated: {original} -> {result} -> {recovered}"

{% endfor %}

# =============================================================================
# IDEMPOTENT PROPERTIES
# =============================================================================

{% for prop in properties if prop.type == "idempotent" %}
class Test{{prop.name}}Idempotent:
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}
    Formula: {{prop.formula}}
    """

    @given({{prop.generator}})
    @settings(max_examples=100)
    {% for ex in prop.shrunk_examples %}
    @example({{ex}})
    {% endfor %}
    def test_{{prop.name|lower}}_idempotent(self, value):
        """
        Property: {{prop.formula}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
        """
        # Act - apply once
        once = {{prop.function}}(value)

        # Act - apply twice
        twice = {{prop.function}}(once)

        # Assert - idempotent
        assert once == twice, \
            f"Idempotent violated: f({value}) = {once}, f(f({value})) = {twice}"

{% endfor %}

# =============================================================================
# INVARIANT PROPERTIES
# =============================================================================

{% for prop in properties if prop.type == "invariant" %}
class Test{{prop.name}}Invariant:
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}
    Formula: {{prop.formula}}
    {% if prop.statistical %}Statistical: Yes (sample_size={{prop.sample_size}}){% endif %}
    """

    @given({{prop.generator}})
    @settings(max_examples={{prop.sample_size if prop.statistical else 100}}, deadline=None)
    def test_{{prop.name|lower}}_invariant(self, state):
        """
        Property: {{prop.formula}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
        """
        {% if prop.conditional %}
        # Precondition
        assume({{prop.condition}})
        {% endif %}

        # Act
        result = {{prop.operation}}(state)

        # Assert invariant
        assert {{prop.invariant_check}}, \
            f"Invariant violated for state {state}: result = {result}"

{% endfor %}

# =============================================================================
# BOUNDARY PROPERTIES
# =============================================================================

{% for prop in properties if prop.type == "boundary" %}
class Test{{prop.name}}Boundary:
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}
    Severity: {{prop.severity}}
    {% if prop.security_category %}Security: {{prop.security_category}}{% endif %}
    Formula: {{prop.formula}}
    """

    @given({{prop.boundary_generator}})
    @settings(max_examples=100)
    {% for ex in prop.shrunk_examples %}
    @example({{ex}})
    {% endfor %}
    def test_{{prop.name|lower}}_boundary(self, boundary_value):
        """
        Property: {{prop.formula}}
        EARS: {{prop.ears_form}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
        """
        # Assert boundary behavior
        with pytest.raises({{prop.expected_exception}}):
            {{prop.operation}}(boundary_value)

    {% if prop.security_category %}
    @given({{prop.security_generator}})
    @settings(max_examples=100)
    {% for ex in prop.security_shrunk_examples %}
    @example({{ex}})
    {% endfor %}
    def test_{{prop.name|lower}}_security(self, attack_payload):
        """
        Security Property: {{prop.security_category}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}},SEC:{{prop.security_category}}]
        """
        # Should either reject or sanitize - never execute malicious input
        try:
            result = {{prop.operation}}(attack_payload)
            # If didn't raise, verify it was sanitized
            assert {{prop.sanitization_check}}, \
                f"Security violation: {attack_payload} was not sanitized"
        except {{prop.expected_exception}}:
            pass  # Expected - invalid input rejected
        except Exception as e:
            # Check for security-related errors
            assert "{{prop.security_error_pattern}}" not in str(e).upper(), \
                f"Possible security vulnerability: {e}"
    {% endif %}

{% endfor %}

# =============================================================================
# COMMUTATIVE PROPERTIES
# =============================================================================

{% for prop in properties if prop.type == "commutative" %}
class Test{{prop.name}}Commutative:
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}
    Formula: {{prop.formula}}
    """

    @given({{prop.generator_a}}, {{prop.generator_b}})
    @settings(max_examples=100)
    def test_{{prop.name|lower}}_commutative(self, a, b):
        """
        Property: {{prop.formula}}
        @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
        """
        # Act - both orders
        result_ab = {{prop.function}}(a, b)
        result_ba = {{prop.function}}(b, a)

        # Assert - commutative
        assert result_ab == result_ba, \
            f"Commutative violated: f({a}, {b}) = {result_ab}, f({b}, {a}) = {result_ba}"

{% endfor %}

# =============================================================================
# MODEL-BASED PROPERTIES (Stateful Testing)
# =============================================================================

{% for prop in properties if prop.type == "model_based" %}
class {{prop.name}}StateMachine(RuleBasedStateMachine):
    """
    PROP-{{prop.id}}: {{prop.description}}
    Trace: {{prop.trace}}

    Model-based testing using Hypothesis stateful testing.
    The model is a simplified version of the system that's easy to verify.
    """

    def __init__(self):
        super().__init__()
        # Initialize model (simplified, known-correct)
        self.model = {{prop.model_class}}()
        # Initialize system under test
        self.system = {{prop.system_class}}()

    @invariant()
    def states_must_match(self):
        """
        Invariant: Model state always matches system state.
        @speckit[PROP:{{prop.id}},STATE:*]
        """
        model_state = self.model.get_state()
        system_state = self.system.get_state()
        assert model_state == system_state, \
            f"State mismatch: model={model_state}, system={system_state}"

    {% for transition in prop.transitions %}
    @rule({{transition.params}})
    @precondition(lambda self: self.model.can_{{transition.name}}())
    def {{transition.name}}(self, {{transition.param_names}}):
        """
        Transition: {{transition.from}} -> {{transition.to}}
        Trace: {{transition.trace}}
        """
        # Apply to model
        self.model.{{transition.name}}({{transition.param_names}})
        # Apply to system
        self.system.{{transition.name}}({{transition.param_names}})
        # Note for debugging
        note(f"After {{transition.name}}: state={self.model.get_state()}")
    {% endfor %}

# Create test case from state machine
Test{{prop.name}}StateMachine = {{prop.name}}StateMachine.TestCase
{% endfor %}

# =============================================================================
# SHRUNK EXAMPLES REGISTRY
# =============================================================================

SHRUNK_EXAMPLES = {
    {% for prop in properties if prop.shrunk_examples %}
    "{{prop.id}}": [
        {% for ex in prop.shrunk_examples %}
        {{ex}},  # Found: {{ex.date}}, Iteration: {{ex.iteration}}
        {% endfor %}
    ],
    {% endfor %}
}
```

---

## Running Tests

```bash
# Run all property tests
pytest tests/properties/ -v

# Run with statistics
pytest tests/properties/ --hypothesis-show-statistics

# Run with specific profile
HYPOTHESIS_PROFILE=ci pytest tests/properties/

# Run with seed for reproducibility
pytest tests/properties/ --hypothesis-seed=12345

# Run specific property
pytest tests/properties/test_user_properties.py::TestUserInverse -v
```

---

## Best Practices

### 1. Use @example for Shrunk Cases

```python
@given(valid_user())
@example(User(email="a@b.c", password="P1", name=""))  # Shrunk case
def test_user_property(user):
    ...
```

### 2. Use assume() for Preconditions

```python
@given(integers())
def test_positive_property(n):
    assume(n > 0)  # Only test positive numbers
    assert math.sqrt(n) ** 2 == pytest.approx(n)
```

### 3. Use note() for Debugging

```python
@given(valid_user())
def test_user_creation(user):
    note(f"Testing with user: {user}")
    result = create_user(**user)
    note(f"Created user ID: {result.id}")
    ...
```

### 4. Custom Settings for Slow Tests

```python
@given(complex_generator())
@settings(max_examples=50, deadline=timedelta(seconds=30))
def test_slow_property(data):
    ...
```

### 5. Stateful Testing for Workflows

```python
class ShoppingCartStateMachine(RuleBasedStateMachine):
    @invariant()
    def cart_total_correct(self):
        assert self.cart.total == sum(item.price for item in self.cart.items)

    @rule(item=valid_item())
    def add_item(self, item):
        self.cart.add(item)

    @rule()
    @precondition(lambda self: len(self.cart.items) > 0)
    def remove_last_item(self):
        self.cart.remove_last()
```
