# Kotlin Kotest Property Generator Template

This document defines the code generation templates for Kotlin property-based tests using [Kotest Property Testing](https://kotest.io/docs/proptest/property-based-testing.html).

## File Structure

```
src/test/kotlin/
└── properties/
    ├── Generators.kt              # Custom Arb generators
    └── [Feature]PropertyTest.kt   # Property tests
```

---

## Template: Generators.kt

```kotlin
// src/test/kotlin/properties/Generators.kt
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Custom Arb generators for property-based tests

package {{package}}.properties

import io.kotest.property.Arb
import io.kotest.property.arbitrary.*
import java.time.LocalDate
import java.time.LocalDateTime
import java.util.UUID

// =============================================================================
// PRIMITIVE GENERATORS
// =============================================================================

// String arbitraries
val validEmail: Arb<String> = Arb.email()

val validUuid: Arb<String> = Arb.uuid().map { it.toString() }

val validUrl: Arb<String> = Arb.domain().map { domain ->
    val protocol = listOf("http", "https").random()
    val path = Arb.stringPattern("[a-z]{0,10}").single()
    "$protocol://$domain/$path"
}

val validPhone: Arb<String> = Arb.stringPattern("\\+1[0-9]{10}")

// Numeric arbitraries
val positiveInt: Arb<Int> = Arb.positiveInt()

val nonNegativeInt: Arb<Int> = Arb.int(min = 0)

val percentage: Arb<Double> = Arb.double(min = 0.0, max = 100.0)

val moneyAmount: Arb<Double> = Arb.double(min = 0.0, max = 999999.99)
    .map { (it * 100).toLong() / 100.0 } // Round to 2 decimal places

// Date arbitraries
val futureDate: Arb<LocalDate> = Arb.localDate(
    minDate = LocalDate.now().plusDays(1),
    maxDate = LocalDate.now().plusYears(10)
)

val pastDate: Arb<LocalDate> = Arb.localDate(
    minDate = LocalDate.now().minusYears(10),
    maxDate = LocalDate.now().minusDays(1)
)

// Password arbitraries
val validPassword: Arb<String> = arbitrary {
    val lower = Arb.char('a'..'z').bind()
    val upper = Arb.char('A'..'Z').bind()
    val digit = Arb.char('0'..'9').bind()
    val rest = Arb.string(minSize = 5, maxSize = 121).bind()
    "$lower$upper$digit$rest"
}

// =============================================================================
// BOUNDARY GENERATORS
// =============================================================================

val invalidEmail: Arb<String> = Arb.choice(
    Arb.constant(""),                                    // Empty
    Arb.constant("@"),                                   // No local part
    Arb.constant("a@"),                                  // No domain
    Arb.constant("@b.com"),                              // No local part
    Arb.constant("a@b"),                                 // No TLD
    Arb.constant("a@@b.com"),                            // Double @
    Arb.string().filter { !it.contains("@") },           // Missing @
    Arb.string().filter { it.count { c -> c == '@' } > 1 } // Multiple @
)

val boundaryString: Arb<String> = Arb.choice(
    Arb.constant(""),                                    // Empty
    Arb.constant(" "),                                   // Whitespace only
    Arb.constant("\n"),                                  // Newline only
    Arb.constant("\t"),                                  // Tab only
    Arb.constant("a".repeat(1000)),                      // Very long
    Arb.string(minSize = 1, maxSize = 10, codepoints = Arb.of(0x1F389, 0x1F38A, 0x1F381)) // Emoji only
)

val boundaryInt: Arb<Int> = Arb.choice(
    Arb.constant(0),
    Arb.constant(-1),
    Arb.constant(1),
    Arb.constant(Int.MAX_VALUE),
    Arb.constant(Int.MIN_VALUE)
)

val boundaryLong: Arb<Long> = Arb.choice(
    Arb.constant(0L),
    Arb.constant(-1L),
    Arb.constant(1L),
    Arb.constant(Long.MAX_VALUE),
    Arb.constant(Long.MIN_VALUE)
)

// =============================================================================
// SECURITY GENERATORS
// =============================================================================

val sqlInjectionPayloads: Arb<String> = Arb.choice(
    Arb.constant("'; DROP TABLE users; --"),
    Arb.constant("' OR '1'='1"),
    Arb.constant("admin'--"),
    Arb.constant("1; SELECT * FROM users"),
    Arb.constant("' UNION SELECT * FROM users--"),
    Arb.constant("1' AND '1'='1"),
    Arb.stringPattern(".*[';].*")
)

val xssPayloads: Arb<String> = Arb.choice(
    Arb.constant("<script>alert('xss')</script>"),
    Arb.constant("<img src=x onerror=alert('xss')>"),
    Arb.constant("javascript:alert('xss')"),
    Arb.constant("<svg onload=alert('xss')>"),
    Arb.constant("'><script>alert('xss')</script>")
)

val pathTraversalPayloads: Arb<String> = Arb.choice(
    Arb.constant("../../../etc/passwd"),
    Arb.constant("..\\..\\..\\windows\\system32"),
    Arb.constant("%2e%2e%2f%2e%2e%2f"),
    Arb.constant("....//....//")
)

val commandInjectionPayloads: Arb<String> = Arb.choice(
    Arb.constant("; rm -rf /"),
    Arb.constant("| cat /etc/passwd"),
    Arb.constant("\$(whoami)"),
    Arb.constant("`id`"),
    Arb.constant("& ping -c 10 localhost &")
)

// Combined security payload generator
val allSecurityPayloads: Arb<String> = Arb.choice(
    sqlInjectionPayloads,
    xssPayloads,
    pathTraversalPayloads,
    commandInjectionPayloads
)

// =============================================================================
// ENTITY GENERATORS
// =============================================================================

{% for entity in entities %}
// {{entity.name}} data class
data class {{entity.name}}(
    {% for field in entity.fields %}
    val {{field.name}}: {{field.kotlin_type}},
    {% endfor %}
)

// {{entity.name}} arbitraries
val valid{{entity.name}}: Arb<{{entity.name}}> = arbitrary {
    {{entity.name}}(
        {% for field in entity.fields %}
        {{field.name}} = {{field.valid_arb}}.bind(),
        {% endfor %}
    )
}

val boundary{{entity.name}}: Arb<{{entity.name}}> = arbitrary {
    {{entity.name}}(
        {% for field in entity.fields %}
        {{field.name}} = {{field.boundary_arb}}.bind(),
        {% endfor %}
    )
}

{% if entity.has_security_fields %}
val security{{entity.name}}: Arb<{{entity.name}}> = arbitrary {
    {{entity.name}}(
        {% for field in entity.security_fields %}
        {{field.name}} = {{field.security_arb}}.bind(),
        {% endfor %}
    )
}
{% endif %}
{% endfor %}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Create an arbitrary that includes specific shrunk examples
 */
fun <T> Arb<T>.withShrunkExamples(examples: List<T>): Arb<T> {
    if (examples.isEmpty()) return this
    return Arb.choice(
        this,
        *examples.map { Arb.constant(it) }.toTypedArray()
    )
}

/**
 * Create weighted arbitrary with edge cases
 */
fun <T> Arb.Companion.weighted(
    primary: Pair<Arb<T>, Int>,
    vararg others: Pair<Arb<T>, Int>
): Arb<T> {
    val all = listOf(primary) + others.toList()
    return arbitrary {
        val totalWeight = all.sumOf { it.second }
        val random = Arb.int(1..totalWeight).bind()
        var cumulative = 0
        for ((arb, weight) in all) {
            cumulative += weight
            if (random <= cumulative) {
                return@arbitrary arb.bind()
            }
        }
        all.last().first.bind()
    }
}
```

---

## Template: Property Test File

```kotlin
// src/test/kotlin/properties/{{FeatureName}}PropertyTest.kt
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Generated: {{TIMESTAMP}}
//
// Property-Based Tests for {{FEATURE_NAME}}
// Based on: spec.md, properties.md
//
// Run: ./gradlew test --tests "*PropertyTest"

package {{package}}.properties

import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.property.Arb
import io.kotest.property.PropTestConfig
import io.kotest.property.arbitrary.*
import io.kotest.property.assume
import io.kotest.property.checkAll
import io.kotest.property.forAll

// Import generators
import {{package}}.properties.*

// Import system under test
import {{module}}.*
import {{module}}.exceptions.ValidationException
import {{module}}.exceptions.DuplicateException

// =============================================================================
// TEST CONFIGURATION
// =============================================================================

val propTestConfig = PropTestConfig(
    iterations = 100,
    seed = null // Set for reproducibility, e.g., 12345L
)

// Shrunk examples from previous runs
object ShrunkExamples {
    {% for prop in properties if prop.shrunk_examples %}
    val {{prop.id}}: List<{{prop.input_type}}> = listOf(
        {% for ex in prop.shrunk_examples %}
        {{ex.kotlin_value}}, // Found: {{ex.date}}, Iteration: {{ex.iteration}}
        {% endfor %}
    )
    {% endfor %}
}

// =============================================================================
// PROPERTY TESTS
// =============================================================================

class {{FeatureName}}PropertyTest : FunSpec({

    // =========================================================================
    // INVERSE PROPERTIES
    // =========================================================================

    {% for prop in properties if prop.type == "inverse" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Inverse)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * Formula: {{prop.formula}}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should satisfy: {{prop.formula}}") {
            checkAll(
                propTestConfig,
                {{prop.generator}}.withShrunkExamples(ShrunkExamples.{{prop.id}} ?: emptyList())
            ) { value ->
                // Forward operation
                val result = {{prop.forward_function}}(value)
                {{prop.forward_assertion}}

                // Inverse operation
                val recovered = {{prop.inverse_function}}(result)

                // Round-trip assertion
                recovered shouldBe value
            }
        }

        {% for ex in prop.shrunk_examples %}
        test("shrunk example: {{ex.description}}") {
            // @speckit[PROP:{{prop.id}},SHRUNK:{{ex.iteration}}]
            val value = {{ex.kotlin_value}}
            val result = {{prop.forward_function}}(value)
            val recovered = {{prop.inverse_function}}(result)
            recovered shouldBe value
        }
        {% endfor %}
    }

    {% endfor %}

    // =========================================================================
    // IDEMPOTENT PROPERTIES
    // =========================================================================

    {% for prop in properties if prop.type == "idempotent" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Idempotent)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * Formula: {{prop.formula}}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should satisfy: {{prop.formula}}") {
            checkAll(propTestConfig, {{prop.generator}}) { value ->
                // Apply once
                val once = {{prop.function}}(value)

                // Apply twice
                val twice = {{prop.function}}(once)

                // Idempotent assertion
                once shouldBe twice
            }
        }

        {% for ex in prop.shrunk_examples %}
        test("shrunk example: {{ex.description}}") {
            // @speckit[PROP:{{prop.id}},SHRUNK:{{ex.iteration}}]
            val value = {{ex.kotlin_value}}
            val once = {{prop.function}}(value)
            val twice = {{prop.function}}(once)
            once shouldBe twice
        }
        {% endfor %}
    }

    {% endfor %}

    // =========================================================================
    // INVARIANT PROPERTIES
    // =========================================================================

    {% for prop in properties if prop.type == "invariant" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Invariant)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * Formula: {{prop.formula}}
         * {% if prop.statistical %}Statistical: Yes (samples={{prop.sample_size}}){% endif %}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should maintain: {{prop.formula}}") {
            val config = propTestConfig.copy(
                iterations = {{prop.sample_size if prop.statistical else 100}}
            )

            checkAll(config, {{prop.generator}}) { state ->
                {% if prop.conditional %}
                // Precondition check
                assume({{prop.condition}})
                {% endif %}

                // Operation
                val result = {{prop.operation}}(state)

                // Invariant check
                ({{prop.invariant_check}}) shouldBe true
            }
        }
    }

    {% endfor %}

    // =========================================================================
    // BOUNDARY PROPERTIES
    // =========================================================================

    {% for prop in properties if prop.type == "boundary" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Boundary)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * Severity: {{prop.severity}}
         * {% if prop.security_category %}Security: {{prop.security_category}}{% endif %}
         * EARS: {{prop.ears_form}}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should reject boundary values with {{prop.expected_exception}}") {
            checkAll(
                propTestConfig,
                {{prop.boundary_generator}}.withShrunkExamples(ShrunkExamples.{{prop.id}} ?: emptyList())
            ) { boundaryValue ->
                shouldThrow<{{prop.expected_exception}}> {
                    {{prop.operation}}(boundaryValue)
                }
            }
        }

        {% for ex in prop.shrunk_examples %}
        test("shrunk boundary: {{ex.description}}") {
            // @speckit[PROP:{{prop.id}},SHRUNK:{{ex.iteration}}]
            val boundaryValue = {{ex.kotlin_value}}
            shouldThrow<{{prop.expected_exception}}> {
                {{prop.operation}}(boundaryValue)
            }
        }
        {% endfor %}

        {% if prop.security_category %}
        test("should prevent security attacks: {{prop.security_category}}") {
            // @speckit[PROP:{{prop.id}},{{prop.trace_annotation}},SEC:{{prop.security_category}}]
            checkAll(propTestConfig, {{prop.security_generator}}) { attackPayload ->
                try {
                    val result = {{prop.operation}}(attackPayload)
                    // If didn't throw, verify sanitization
                    ({{prop.sanitization_check}}) shouldBe true
                } catch (e: {{prop.expected_exception}}) {
                    // Expected - attack was rejected
                }
            }
        }

        {% for ex in prop.security_shrunk_examples %}
        test("shrunk security: {{ex.description}}") {
            // @speckit[PROP:{{prop.id}},SEC:{{prop.security_category}},SHRUNK:{{ex.iteration}}]
            val attackPayload = {{ex.kotlin_value}}
            try {
                val result = {{prop.operation}}(attackPayload)
                ({{prop.sanitization_check}}) shouldBe true
            } catch (e: {{prop.expected_exception}}) {
                // Expected
            }
        }
        {% endfor %}
        {% endif %}
    }

    {% endfor %}

    // =========================================================================
    // COMMUTATIVE PROPERTIES
    // =========================================================================

    {% for prop in properties if prop.type == "commutative" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Commutative)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * Formula: {{prop.formula}}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should satisfy: {{prop.formula}}") {
            checkAll(propTestConfig, {{prop.generator_a}}, {{prop.generator_b}}) { a, b ->
                // Both orders
                val resultAB = {{prop.function}}(a, b)
                val resultBA = {{prop.function}}(b, a)

                // Commutative assertion
                resultAB shouldBe resultBA
            }
        }
    }

    {% endfor %}

    // =========================================================================
    // MODEL-BASED PROPERTIES (Stateful Testing)
    // =========================================================================

    {% for prop in properties if prop.type == "model_based" %}
    context("PROP-{{prop.id}}: {{prop.name}} (Model-Based)") {
        /**
         * {{prop.description}}
         * Trace: {{prop.trace}}
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */

        test("should maintain model consistency across all transitions") {
            checkAll(propTestConfig, Arb.int(1..50)) { numOperations ->
                // Initialize model and system
                val model = {{prop.ModelClass}}()
                val system = {{prop.SystemClass}}()

                repeat(numOperations) {
                    // Generate random operation
                    val operation = Arb.element(listOf(
                        {% for op in prop.operations %}
                        "{{op.name}}",
                        {% endfor %}
                    )).single()

                    when (operation) {
                        {% for op in prop.operations %}
                        "{{op.name}}" -> {
                            {{op.params_gen}}
                            if (model.can{{op.name|capitalize}}({{op.params}})) {
                                model.{{op.name}}({{op.params}})
                                system.{{op.name}}({{op.params}})
                            }
                        }
                        {% endfor %}
                    }

                    // Invariant: model and system states match
                    system.getState() shouldBe model.getState()
                }
            }
        }

        {% for transition in prop.transitions %}
        test("transition {{transition.name}}: {{transition.from}} -> {{transition.to}}") {
            // @speckit[PROP:{{prop.id}},TRANSITION:{{transition.name}}]
            val model = {{prop.ModelClass}}()
            val system = {{prop.SystemClass}}()

            checkAll(propTestConfig, {{transition.params_arb}}) { params ->
                assume(model.can{{transition.name|capitalize}}(params))

                model.{{transition.name}}(params)
                system.{{transition.name}}(params)

                system.getState() shouldBe model.getState()
            }
        }
        {% endfor %}
    }

    {% endfor %}
})

// =============================================================================
// ALTERNATIVE STYLE: forAll for Boolean Properties
// =============================================================================

class {{FeatureName}}ForAllPropertyTest : FunSpec({

    {% for prop in properties if prop.type == "inverse" %}
    test("forAll: PROP-{{prop.id}} - {{prop.name}}") {
        /**
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */
        forAll({{prop.generator}}) { value ->
            val result = {{prop.forward_function}}(value)
            val recovered = {{prop.inverse_function}}(result)
            recovered == value
        }
    }
    {% endfor %}

    {% for prop in properties if prop.type == "idempotent" %}
    test("forAll: PROP-{{prop.id}} - {{prop.name}}") {
        /**
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */
        forAll({{prop.generator}}) { value ->
            val once = {{prop.function}}(value)
            val twice = {{prop.function}}(once)
            once == twice
        }
    }
    {% endfor %}

    {% for prop in properties if prop.type == "commutative" %}
    test("forAll: PROP-{{prop.id}} - {{prop.name}}") {
        /**
         * @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
         */
        forAll({{prop.generator_a}}, {{prop.generator_b}}) { a, b ->
            {{prop.function}}(a, b) == {{prop.function}}(b, a)
        }
    }
    {% endfor %}
})
```

---

## Running Tests

```bash
# Run all property tests
./gradlew test --tests "*PropertyTest"

# Run with specific seed for reproducibility
./gradlew test --tests "*PropertyTest" -Dkotest.proptest.seed=12345

# Run specific property test class
./gradlew test --tests "{{package}}.properties.{{FeatureName}}PropertyTest"

# Run specific test
./gradlew test --tests "*PropertyTest.PROP-001*"

# Run with verbose output
./gradlew test --tests "*PropertyTest" --info

# Run with increased iterations
./gradlew test --tests "*PropertyTest" -Dkotest.proptest.default.iteration.count=1000

# Run with test report
./gradlew test --tests "*PropertyTest" --continue
open build/reports/tests/test/index.html
```

---

## Gradle Configuration

```kotlin
// build.gradle.kts

plugins {
    kotlin("jvm") version "1.9.22"
}

dependencies {
    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    testImplementation("io.kotest:kotest-property:5.8.0")
}

tasks.withType<Test>().configureEach {
    useJUnitPlatform()

    // Kotest configuration via system properties
    systemProperty("kotest.proptest.default.iteration.count", "100")
    systemProperty("kotest.proptest.output.shrunk-values", "true")
}
```

---

## Best Practices

### 1. Use assume() for Preconditions

```kotlin
checkAll(Arb.int()) { n ->
    assume(n > 0) // Only test positive numbers
    val sqrt = kotlin.math.sqrt(n.toDouble())
    (sqrt * sqrt).toInt() shouldBe n
}
```

### 2. Use arbitrary {} for Custom Generators with bind()

```kotlin
val validUser: Arb<User> = arbitrary {
    User(
        email = Arb.email().bind(),
        password = validPassword.bind(),
        name = Arb.string(minSize = 1, maxSize = 100).bind(),
        age = Arb.int(18..120).bind()
    )
}
```

### 3. Use Arb.choice() for Boundary Cases

```kotlin
val emailArbitrary: Arb<String> = Arb.choice(
    Arb.email(),           // Valid emails (most common)
    invalidEmail,          // Invalid emails
    Arb.constant("")       // Edge case: empty
)
```

### 4. Use shouldThrow for Exception Testing

```kotlin
checkAll(invalidEmail) { email ->
    shouldThrow<ValidationException> {
        validateEmail(email)
    }
}
```

### 5. Use forAll for Simple Boolean Properties

```kotlin
forAll(Arb.string()) { s ->
    s.reversed().reversed() == s
}
```

### 6. Configure PropTestConfig for Different Scenarios

```kotlin
// Quick smoke test
val quickConfig = PropTestConfig(iterations = 10)

// Thorough testing
val thoroughConfig = PropTestConfig(iterations = 1000)

// Reproducible test
val reproducibleConfig = PropTestConfig(seed = 12345L)

// CI configuration
val ciConfig = PropTestConfig(
    iterations = 200,
    edgecasesGenerationProbability = 0.2
)
```

### 7. Model-Based Stateful Testing Pattern

```kotlin
class CartModel {
    private val items = mutableListOf<Item>()
    private var total = 0.0

    fun canAddItem(item: Item): Boolean = items.size < 100

    fun addItem(item: Item) {
        items.add(item)
        total += item.price
    }

    fun canRemoveItem(): Boolean = items.isNotEmpty()

    fun removeItem() {
        if (items.isNotEmpty()) {
            total -= items.removeLast().price
        }
    }

    fun getState(): Pair<Int, Double> = items.size to total
}

// Test model against real implementation
checkAll(Arb.int(1..100)) { numOps ->
    val model = CartModel()
    val real = ShoppingCart()

    repeat(numOps) {
        val item = validItem.single()
        if (model.canAddItem(item)) {
            model.addItem(item)
            real.addItem(item)
        }
    }

    real.getState() shouldBe model.getState()
}
```

### 8. Use @speckit Trace Annotations

```kotlin
/**
 * Property: encode(decode(x)) == x
 * @speckit[PROP:PROP-001,REQ:FR-AUTH-001,AC:AC-001.1]
 */
test("should satisfy encode/decode round-trip") {
    checkAll(validToken) { token ->
        val encoded = encode(token)
        val decoded = decode(encoded)
        decoded shouldBe token
    }
}
```

### 9. Explicit Test Cases for Shrunk Examples

```kotlin
// Shrunk examples discovered during property testing
// These serve as regression tests

test("shrunk example: empty string edge case") {
    // @speckit[PROP:PROP-002,SHRUNK:2024-01-15,ITER:42]
    val input = ""
    shouldThrow<ValidationException> {
        validate(input)
    }
}

test("shrunk example: unicode boundary") {
    // @speckit[PROP:PROP-002,SHRUNK:2024-01-15,ITER:108]
    val input = "\uD83D\uDE00" // Emoji
    val result = process(input)
    result.isValid shouldBe true
}
```

### 10. Combine with Exhaustive Testing for Small Domains

```kotlin
import io.kotest.property.exhaustive.exhaustive

enum class Status { PENDING, ACTIVE, COMPLETED, CANCELLED }

// Use exhaustive for small enum domains
val allStatuses = Status.values().toList().exhaustive()

test("status transitions are valid") {
    checkAll(allStatuses, allStatuses) { from, to ->
        // All transitions from any status should be well-defined
        val canTransition = StatusMachine.canTransition(from, to)
        canTransition shouldNotBe null
    }
}
```
