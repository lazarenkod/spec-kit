# Go rapid Generator Template

This document defines the code generation templates for Go property-based tests using [rapid](https://pkg.go.dev/pgregory.net/rapid).

## File Structure

```
[package]/
├── generators_test.go        # Custom generators
└── property_test.go          # Property tests
```

---

## Template: generators_test.go

```go
// generators_test.go
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Custom generators for property-based tests

package {{package}}_test

import (
    "regexp"
    "strings"
    "time"
    "unicode"

    "pgregory.net/rapid"
)

// =============================================================================
// PRIMITIVE GENERATORS
// =============================================================================

// String generators
func genValidEmail() *rapid.Generator[string] {
    return rapid.Custom(func(t *rapid.T) string {
        local := rapid.StringOfN(rapid.RuneFrom(nil, 'a', 'z', '0', '9', '.', '_'), 1, 64).Draw(t, "local")
        domain := rapid.StringOfN(rapid.RuneFrom(nil, 'a', 'z', '0', '9'), 1, 63).Draw(t, "domain")
        tld := rapid.SampledFrom([]string{"com", "org", "net", "io", "dev"}).Draw(t, "tld")
        return local + "@" + domain + "." + tld
    })
}

func genValidUUID() *rapid.Generator[string] {
    return rapid.Custom(func(t *rapid.T) string {
        hex := "0123456789abcdef"
        parts := []int{8, 4, 4, 4, 12}
        var result strings.Builder
        for i, length := range parts {
            if i > 0 {
                result.WriteRune('-')
            }
            for j := 0; j < length; j++ {
                result.WriteByte(hex[rapid.IntRange(0, 15).Draw(t, "hex")])
            }
        }
        return result.String()
    })
}

func genValidPassword() *rapid.Generator[string] {
    return rapid.Custom(func(t *rapid.T) string {
        // Ensure at least one of each required character type
        lower := string(rapid.RuneFrom(nil, 'a', 'z').Draw(t, "lower"))
        upper := string(rapid.RuneFrom(nil, 'A', 'Z').Draw(t, "upper"))
        digit := string(rapid.RuneFrom(nil, '0', '9').Draw(t, "digit"))

        // Fill rest with random valid chars
        restLen := rapid.IntRange(5, 125).Draw(t, "restLen")
        rest := rapid.StringOfN(
            rapid.RuneFrom(nil, 'a', 'z', 'A', 'Z', '0', '9', '!', '@', '#', '$'),
            restLen, restLen,
        ).Draw(t, "rest")

        return lower + upper + digit + rest
    })
}

// Numeric generators
func genPositiveInt() *rapid.Generator[int] {
    return rapid.IntRange(1, int(^uint(0)>>1))
}

func genNonNegativeInt() *rapid.Generator[int] {
    return rapid.IntMin(0)
}

func genPercentage() *rapid.Generator[float64] {
    return rapid.Float64Range(0.0, 100.0)
}

// Date generators
func genFutureDate() *rapid.Generator[time.Time] {
    return rapid.Custom(func(t *rapid.T) time.Time {
        days := rapid.IntRange(1, 365*10).Draw(t, "days")
        return time.Now().AddDate(0, 0, days)
    })
}

func genPastDate() *rapid.Generator[time.Time] {
    return rapid.Custom(func(t *rapid.T) time.Time {
        days := rapid.IntRange(1, 365*10).Draw(t, "days")
        return time.Now().AddDate(0, 0, -days)
    })
}

// =============================================================================
// BOUNDARY GENERATORS
// =============================================================================

func genInvalidEmail() *rapid.Generator[string] {
    return rapid.OneOf(
        rapid.Just(""),                                    // Empty
        rapid.Just("@"),                                   // No local part
        rapid.Just("a@"),                                  // No domain
        rapid.Just("@b.com"),                              // No local part
        rapid.Just("a@b"),                                 // No TLD
        rapid.Just("a@@b.com"),                            // Double @
        rapid.StringOf(rapid.RuneFrom(nil, 'a', 'z')),     // Missing @
    )
}

func genBoundaryString() *rapid.Generator[string] {
    return rapid.OneOf(
        rapid.Just(""),                                    // Empty
        rapid.Just(" "),                                   // Whitespace only
        rapid.Just("\n"),                                  // Newline only
        rapid.Just("\t"),                                  // Tab only
        rapid.Just(strings.Repeat("a", 1000)),             // Very long
    )
}

func genBoundaryInt() *rapid.Generator[int] {
    return rapid.OneOf(
        rapid.Just(0),
        rapid.Just(-1),
        rapid.Just(1),
        rapid.Just(int(^uint(0) >> 1)),     // Max int
        rapid.Just(-int(^uint(0)>>1) - 1),  // Min int
    )
}

// =============================================================================
// SECURITY GENERATORS
// =============================================================================

func genSQLInjectionPayload() *rapid.Generator[string] {
    return rapid.SampledFrom([]string{
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "admin'--",
        "1; SELECT * FROM users",
        "' UNION SELECT * FROM users--",
        "1' AND '1'='1",
    })
}

func genXSSPayload() *rapid.Generator[string] {
    return rapid.SampledFrom([]string{
        "<script>alert('xss')</script>",
        "<img src=x onerror=alert('xss')>",
        "javascript:alert('xss')",
        "<svg onload=alert('xss')>",
        "'><script>alert('xss')</script>",
    })
}

func genPathTraversalPayload() *rapid.Generator[string] {
    return rapid.SampledFrom([]string{
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32",
        "%2e%2e%2f%2e%2e%2f",
        "....//....//",
    })
}

func genCommandInjectionPayload() *rapid.Generator[string] {
    return rapid.SampledFrom([]string{
        "; rm -rf /",
        "| cat /etc/passwd",
        "$(whoami)",
        "`id`",
        "& ping -c 10 localhost &",
    })
}

// =============================================================================
// ENTITY GENERATORS
// =============================================================================

{% for entity in entities %}
// {{entity.name}} type
type {{entity.name}} struct {
    {% for field in entity.fields %}
    {{field.name|title}} {{field.go_type}} `json:"{{field.name}}"`
    {% endfor %}
}

// gen{{entity.name}} generates valid {{entity.name}} instances
func gen{{entity.name}}() *rapid.Generator[{{entity.name}}] {
    return rapid.Custom(func(t *rapid.T) {{entity.name}} {
        return {{entity.name}}{
            {% for field in entity.fields %}
            {{field.name|title}}: {{field.valid_generator}}.Draw(t, "{{field.name}}"),
            {% endfor %}
        }
    })
}

// genBoundary{{entity.name}} generates boundary {{entity.name}} instances
func genBoundary{{entity.name}}() *rapid.Generator[{{entity.name}}] {
    return rapid.Custom(func(t *rapid.T) {{entity.name}} {
        return {{entity.name}}{
            {% for field in entity.fields %}
            {{field.name|title}}: {{field.boundary_generator}}.Draw(t, "{{field.name}}"),
            {% endfor %}
        }
    })
}

{% if entity.has_security_fields %}
// genSecurity{{entity.name}} generates {{entity.name}} with security payloads
func genSecurity{{entity.name}}() *rapid.Generator[{{entity.name}}] {
    return rapid.Custom(func(t *rapid.T) {{entity.name}} {
        return {{entity.name}}{
            {% for field in entity.security_fields %}
            {{field.name|title}}: {{field.security_generator}}.Draw(t, "{{field.name}}"),
            {% endfor %}
        }
    })
}
{% endif %}
{% endfor %}
```

---

## Template: Property Test File

```go
// property_test.go
// Generated by /speckit.properties
// Feature: {{FEATURE_ID}}
// Generated: {{TIMESTAMP}}
//
// Property-Based Tests for {{FEATURE_NAME}}
// Based on: spec.md, properties.md
//
// Run: go test -v ./... -run TestProperty

package {{package}}_test

import (
    "errors"
    "reflect"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "pgregory.net/rapid"

    "{{module}}"
)

// =============================================================================
// INVERSE PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "inverse" %}
// TestProperty{{prop.name}}_Inverse tests the inverse property
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// Formula: {{prop.formula}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_Inverse(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate input
        value := {{prop.generator}}.Draw(t, "value")

        // Forward operation
        result, err := {{prop.forward_function}}(value)
        require.NoError(t, err, "Forward operation failed")
        {{prop.forward_assertion}}

        // Inverse operation
        recovered, err := {{prop.inverse_function}}(result)
        require.NoError(t, err, "Inverse operation failed")

        // Round-trip assertion
        if !reflect.DeepEqual(recovered, value) {
            t.Fatalf("Inverse property violated: %v -> %v -> %v", value, result, recovered)
        }
    })
}

{% endfor %}

// =============================================================================
// IDEMPOTENT PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "idempotent" %}
// TestProperty{{prop.name}}_Idempotent tests the idempotent property
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// Formula: {{prop.formula}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_Idempotent(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate input
        value := {{prop.generator}}.Draw(t, "value")

        // Apply once
        once := {{prop.function}}(value)

        // Apply twice
        twice := {{prop.function}}(once)

        // Idempotent assertion
        if !reflect.DeepEqual(once, twice) {
            t.Fatalf("Idempotent property violated: f(%v) = %v, f(f(%v)) = %v",
                value, once, value, twice)
        }
    })
}

{% endfor %}

// =============================================================================
// INVARIANT PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "invariant" %}
// TestProperty{{prop.name}}_Invariant tests the invariant property
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// Formula: {{prop.formula}}
// {% if prop.statistical %}Statistical: Yes (samples={{prop.sample_size}}){% endif %}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_Invariant(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate state
        state := {{prop.generator}}.Draw(t, "state")

        {% if prop.conditional %}
        // Precondition check
        if !({{prop.condition}}) {
            t.Skip("Precondition not met")
            return
        }
        {% endif %}

        // Operation
        result, err := {{prop.operation}}(state)
        if err != nil {
            t.Skip("Operation failed, not checking invariant")
            return
        }

        // Invariant check
        if !({{prop.invariant_check}}) {
            t.Fatalf("Invariant violated for state %v: result = %v", state, result)
        }
    })
}

{% endfor %}

// =============================================================================
// BOUNDARY PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "boundary" %}
// TestProperty{{prop.name}}_Boundary tests the boundary property
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// Severity: {{prop.severity}}
// {% if prop.security_category %}Security: {{prop.security_category}}{% endif %}
// Formula: {{prop.formula}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_Boundary(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate boundary value
        boundaryValue := {{prop.boundary_generator}}.Draw(t, "boundary")

        // Should return error for boundary values
        _, err := {{prop.operation}}(boundaryValue)

        if err == nil {
            t.Fatalf("Expected error for boundary value %v, got nil", boundaryValue)
        }

        // Verify correct error type
        var expectedErr *{{prop.expected_error_type}}
        if !errors.As(err, &expectedErr) {
            t.Fatalf("Expected %T, got %T: %v", expectedErr, err, err)
        }
    })
}

{% if prop.security_category %}
// TestProperty{{prop.name}}_Security tests security against {{prop.security_category}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}},SEC:{{prop.security_category}}]
func TestProperty{{prop.name}}_Security(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate attack payload
        attackPayload := {{prop.security_generator}}.Draw(t, "attack")

        // Should handle securely
        result, err := {{prop.operation}}(attackPayload)

        if err != nil {
            // Expected - attack was rejected
            return
        }

        // If didn't error, verify sanitization
        assert.True(t, {{prop.sanitization_check}},
            "Security violation: %v was not sanitized, result: %v", attackPayload, result)
    })
}
{% endif %}

{% endfor %}

// =============================================================================
// COMMUTATIVE PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "commutative" %}
// TestProperty{{prop.name}}_Commutative tests the commutative property
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// Formula: {{prop.formula}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_Commutative(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Generate two values
        a := {{prop.generator_a}}.Draw(t, "a")
        b := {{prop.generator_b}}.Draw(t, "b")

        // Both orders
        resultAB := {{prop.function}}(a, b)
        resultBA := {{prop.function}}(b, a)

        // Commutative assertion
        if !reflect.DeepEqual(resultAB, resultBA) {
            t.Fatalf("Commutative property violated: f(%v, %v) = %v, f(%v, %v) = %v",
                a, b, resultAB, b, a, resultBA)
        }
    })
}

{% endfor %}

// =============================================================================
// MODEL-BASED PROPERTIES
// =============================================================================

{% for prop in properties if prop.type == "model_based" %}
// TestProperty{{prop.name}}_ModelBased tests against a simplified model
// PROP-{{prop.id}}: {{prop.description}}
// Trace: {{prop.trace}}
// @speckit[PROP:{{prop.id}},{{prop.trace_annotation}}]
func TestProperty{{prop.name}}_ModelBased(t *testing.T) {
    rapid.Check(t, func(t *rapid.T) {
        // Initialize model and system
        model := {{prop.new_model}}()
        system := {{prop.new_system}}()

        // Generate random sequence of operations
        numOps := rapid.IntRange(1, 50).Draw(t, "numOps")

        for i := 0; i < numOps; i++ {
            op := rapid.SampledFrom([]string{
                {% for op in prop.operations %}
                "{{op.name}}",
                {% endfor %}
            }).Draw(t, "operation")

            switch op {
            {% for op in prop.operations %}
            case "{{op.name}}":
                {{op.params_gen}}
                if model.Can{{op.name|title}}({{op.params}}) {
                    model.{{op.name|title}}({{op.params}})
                    system.{{op.name|title}}({{op.params}})
                }
            {% endfor %}
            }

            // Invariant: model and system states match
            modelState := model.GetState()
            systemState := system.GetState()
            if modelState != systemState {
                t.Fatalf("Model state %v != System state %v after operation %s",
                    modelState, systemState, op)
            }
        }
    })
}

{% endfor %}

// =============================================================================
// SHRUNK EXAMPLES (Regression Tests)
// =============================================================================

// These are minimal counterexamples found by rapid that should be
// preserved as regression tests.

{% for prop in properties if prop.shrunk_examples %}
func TestShrunkExample_{{prop.id}}(t *testing.T) {
    examples := []{{prop.input_type}}{
        {% for ex in prop.shrunk_examples %}
        {{ex.go_value}}, // Found: {{ex.date}}, Iteration: {{ex.iteration}}
        {% endfor %}
    }

    for _, example := range examples {
        t.Run("", func(t *testing.T) {
            {{prop.shrunk_test_code}}
        })
    }
}
{% endfor %}
```

---

## Running Tests

```bash
# Run all property tests
go test -v ./... -run TestProperty

# Run with count for more iterations
go test -v ./... -run TestProperty -count=10

# Run with race detector
go test -v ./... -run TestProperty -race

# Run specific property
go test -v ./... -run TestPropertyUserCreate_Inverse

# Run with timeout
go test -v ./... -run TestProperty -timeout 5m

# Run with seed for reproducibility
RAPID_SEED=12345 go test -v ./... -run TestProperty
```

---

## Best Practices

### 1. Use rapid.Custom for Complex Generators

```go
func genValidUser() *rapid.Generator[User] {
    return rapid.Custom(func(t *rapid.T) User {
        return User{
            Email:    genValidEmail().Draw(t, "email"),
            Password: genValidPassword().Draw(t, "password"),
            Name:     rapid.StringOfN(rapid.Rune(), 1, 100).Draw(t, "name"),
        }
    })
}
```

### 2. Use rapid.OneOf for Boundary Cases

```go
func genBoundaryValue() *rapid.Generator[int] {
    return rapid.OneOf(
        rapid.Just(0),
        rapid.Just(-1),
        rapid.Just(math.MaxInt64),
        rapid.IntRange(-100, 100),
    )
}
```

### 3. Use t.Skip for Precondition Failures

```go
rapid.Check(t, func(t *rapid.T) {
    value := genValue().Draw(t, "value")
    if !validPrecondition(value) {
        t.Skip("Precondition not met")
        return
    }
    // ... rest of test
})
```

### 4. Use reflect.DeepEqual for Struct Comparison

```go
if !reflect.DeepEqual(expected, actual) {
    t.Fatalf("Mismatch: expected %+v, got %+v", expected, actual)
}
```

### 5. Model-Based Testing with State Machine

```go
type Model struct {
    state string
    items []Item
}

func (m *Model) CanAddItem() bool {
    return len(m.items) < 100
}

func (m *Model) AddItem(item Item) {
    m.items = append(m.items, item)
}

func (m *Model) GetState() string {
    return m.state
}
```
