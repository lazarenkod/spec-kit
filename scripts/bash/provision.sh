#!/usr/bin/env bash
# Provision infrastructure using Terraform
# Called by ship.sh for --only infra or full cycle

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# =============================================================================
# CONFIGURATION
# =============================================================================

ENV=""
CLOUD=""
CONFIG=""
STATE_DIR=""
DRY_RUN=false
VERBOSE=false

# Cloud provider endpoints
declare -A S3_ENDPOINTS=(
    ["vk"]="https://hb.bizmrg.com"
    ["yandex"]="https://storage.yandexcloud.net"
    ["gcp"]=""  # GCP uses GCS backend, not S3
)

# =============================================================================
# ARGUMENT PARSING
# =============================================================================

while [[ $# -gt 0 ]]; do
    case $1 in
        --env)
            ENV="$2"
            shift 2
            ;;
        --cloud)
            CLOUD="$2"
            shift 2
            ;;
        --config)
            CONFIG="$2"
            shift 2
            ;;
        --state-dir)
            STATE_DIR="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

log() {
    echo "[provision] $1"
}

log_verbose() {
    [[ "$VERBOSE" == "true" ]] && echo "[provision:verbose] $1"
}

# =============================================================================
# STATE MANAGEMENT
# =============================================================================

# Check if infrastructure exists and is up-to-date
check_infra_state() {
    local state_file="$STATE_DIR/infra-state.json"

    if [[ ! -f "$state_file" ]]; then
        log "No existing infrastructure state found"
        return 1
    fi

    log "Found existing infrastructure state"
    log_verbose "State file: $state_file"
    return 0
}

# Save infrastructure state reference
save_infra_state() {
    local tf_state_path="$1"
    local outputs_file="$STATE_DIR/infra-outputs.json"
    local state_file="$STATE_DIR/infra-state.json"

    # Save Terraform outputs
    terraform -chdir="$TF_DIR" output -json > "$outputs_file"

    # Save state reference
    cat > "$state_file" << EOF
{
  "state_path": "$tf_state_path",
  "outputs_file": "$outputs_file",
  "environment": "$ENV",
  "cloud": "$CLOUD",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "terraform_version": "$(terraform version -json | jq -r '.terraform_version')"
}
EOF

    log "Saved infrastructure state to $state_file"
}

# =============================================================================
# TERRAFORM OPERATIONS
# =============================================================================

# Generate Terraform configuration from infra.yaml
generate_terraform() {
    local tf_dir="$1"
    mkdir -p "$tf_dir"

    log "Generating Terraform configuration for $CLOUD cloud..."

    # Create main.tf
    cat > "$tf_dir/main.tf" << 'EOF'
# Generated by speckit ship
# Do not edit manually - changes will be overwritten

terraform {
  required_version = ">= 1.5.0"
}

# Variables
variable "project_name" {
  type        = string
  description = "Project name for resource naming"
}

variable "environment" {
  type        = string
  description = "Environment (staging, production)"
}

variable "tags" {
  type        = map(string)
  description = "Common tags for all resources"
  default     = {}
}
EOF

    # Add provider configuration based on cloud
    case "$CLOUD" in
        vk)
            cat >> "$tf_dir/main.tf" << 'EOF'

# VK Cloud Provider
terraform {
  required_providers {
    vkcs = {
      source  = "vk-cs/vkcs"
      version = "~> 0.5"
    }
  }
}

provider "vkcs" {
  # Configuration from environment:
  # VK_CLOUD_USERNAME, VK_CLOUD_PASSWORD, VK_CLOUD_PROJECT_ID
}
EOF
            ;;
        yandex)
            cat >> "$tf_dir/main.tf" << 'EOF'

# Yandex Cloud Provider
terraform {
  required_providers {
    yandex = {
      source  = "yandex-cloud/yandex"
      version = "~> 0.100"
    }
  }
}

provider "yandex" {
  # Configuration from environment:
  # YC_TOKEN, YC_CLOUD_ID, YC_FOLDER_ID
}
EOF
            ;;
        gcp)
            cat >> "$tf_dir/main.tf" << 'EOF'

# Google Cloud Provider
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  # Configuration from environment:
  # GOOGLE_PROJECT, GOOGLE_REGION, GOOGLE_CREDENTIALS
}
EOF
            ;;
    esac

    # Add outputs
    cat >> "$tf_dir/main.tf" << 'EOF'

# Outputs
output "database_host" {
  value       = ""  # Populated by resource modules
  description = "Database hostname"
}

output "database_port" {
  value       = "5432"
  description = "Database port"
}

output "redis_host" {
  value       = ""  # Populated by resource modules
  description = "Redis hostname"
}

output "redis_port" {
  value       = "6379"
  description = "Redis port"
}
EOF

    log "Generated Terraform configuration in $tf_dir"
}

# Initialize Terraform with backend
init_terraform() {
    local tf_dir="$1"
    local project_name=$(basename "$(get_repo_root)")

    log "Initializing Terraform..."

    local backend_config=""

    case "$CLOUD" in
        vk|yandex)
            local endpoint="${S3_ENDPOINTS[$CLOUD]}"
            local bucket="${project_name}-tfstate"

            # Create backend.tf
            cat > "$tf_dir/backend.tf" << EOF
terraform {
  backend "s3" {
    bucket   = "$bucket"
    key      = "$ENV/terraform.tfstate"
    endpoint = "$endpoint"
    region   = "ru-msk"

    skip_region_validation      = true
    skip_credentials_validation = true
    skip_metadata_api_check     = true
    force_path_style            = true
  }
}
EOF
            ;;
        gcp)
            local bucket="${project_name}-tfstate"

            cat > "$tf_dir/backend.tf" << EOF
terraform {
  backend "gcs" {
    bucket = "$bucket"
    prefix = "$ENV"
  }
}
EOF
            ;;
    esac

    # Run terraform init
    terraform -chdir="$tf_dir" init -input=false

    log "Terraform initialized"
}

# Plan infrastructure changes
plan_terraform() {
    local tf_dir="$1"
    local plan_file="$tf_dir/tfplan"

    log "Planning infrastructure changes..."

    terraform -chdir="$tf_dir" plan \
        -input=false \
        -out="$plan_file" \
        -detailed-exitcode \
        || local exit_code=$?

    case "${exit_code:-0}" in
        0)
            log "No changes needed"
            return 1  # Signal no changes
            ;;
        1)
            log "Error during plan"
            return 2
            ;;
        2)
            log "Changes detected"
            return 0
            ;;
    esac
}

# Apply infrastructure changes
apply_terraform() {
    local tf_dir="$1"
    local plan_file="$tf_dir/tfplan"

    if [[ "$DRY_RUN" == "true" ]]; then
        log "Dry run mode - skipping apply"
        terraform -chdir="$tf_dir" show -no-color "$plan_file"
        return 0
    fi

    log "Applying infrastructure changes..."

    terraform -chdir="$tf_dir" apply \
        -input=false \
        -auto-approve \
        "$plan_file"

    log "Infrastructure applied successfully"
}

# =============================================================================
# DRIFT DETECTION
# =============================================================================

detect_drift() {
    local tf_dir="$1"

    log "Checking for infrastructure drift..."

    terraform -chdir="$tf_dir" plan \
        -input=false \
        -detailed-exitcode \
        -refresh-only \
        > /dev/null 2>&1 \
        || local exit_code=$?

    case "${exit_code:-0}" in
        0)
            log "No drift detected"
            return 1
            ;;
        2)
            log "Drift detected - infrastructure has changed outside of Terraform"
            return 0
            ;;
        *)
            log "Error checking for drift"
            return 2
            ;;
    esac
}

# =============================================================================
# MAIN
# =============================================================================

main() {
    if [[ -z "$ENV" || -z "$CONFIG" || -z "$STATE_DIR" ]]; then
        echo "Missing required arguments" >&2
        exit 1
    fi

    CLOUD="${CLOUD:-vk}"
    REPO_ROOT=$(get_repo_root)
    TF_DIR="$REPO_ROOT/.speckit/terraform/$ENV"

    log "Provisioning infrastructure for environment: $ENV"
    log "Cloud provider: $CLOUD"
    log_verbose "Config file: $CONFIG"
    log_verbose "Terraform directory: $TF_DIR"

    # Check existing state
    if check_infra_state; then
        # Check for drift
        if [[ -d "$TF_DIR" ]]; then
            if ! detect_drift "$TF_DIR"; then
                log "Infrastructure is up-to-date, skipping provision"
                exit 0
            fi
        fi
    fi

    # Generate Terraform configuration
    generate_terraform "$TF_DIR"

    # Initialize Terraform
    init_terraform "$TF_DIR"

    # Plan changes
    if ! plan_terraform "$TF_DIR"; then
        case $? in
            1)
                log "No changes to apply"
                exit 0
                ;;
            2)
                log "Planning failed"
                exit 1
                ;;
        esac
    fi

    # Apply changes
    apply_terraform "$TF_DIR"

    # Save state
    local tf_state_path="s3://$(basename "$REPO_ROOT")-tfstate/$ENV/terraform.tfstate"
    save_infra_state "$tf_state_path"

    log "Provision complete"
}

main "$@"
